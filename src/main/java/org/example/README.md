1. Сортировка (базовое)
Алгоритмы сортировки -- это очень важный класс алгоритмов, который занимается упорядочиванием элементов в массиве (списке). 
Проблема в том, что самые простые алгоритмы, очевидные в реализации, одновременно и самые неэффективные, медленные. 
Их сложность начинается с O(n^2) и выше, а на практике типичны задачки, когда надо отсортировать наборы 
из миллионов или миллиардов значений.
К простым алгоритмам сортировки обычно относят три типа алгоритмов (рассматриваем упорядочивание по возрастанию).

1. Сортировка выбором

Двигаясь по массиву с начала, берём очередной i-й элемент и меняем его местами с минимальным элементом 
в оставшейся последовательности, начиная с элемента i+1, если этот минимальный элемент меньше текущего.

Например, у нас есть массив (4,3,1,2).
Меняем 0-й элемент 4 и 1:
1,3,4,2
Следующий, 1-й элемент 3 -- меняем с элементом 2:
1,2,4,3
Следующий, 2-й элемент 4 -- меняем с последним элементом 3:
1,2,3,4
Минус, что надо постоянно выполнять поиск минимального элемента.

2. Сортировка пузырьком

Организуем бесконечный цикл, внутри которого выполняем последовательный пробег по всем элементам массива, 
кроме последнего, проверяя, больше ли текущий элемент следующего. Если больше, меняем их местами. 
Таким образом все меньшие элементы постепенно "всплывают" вверх (к началу массива) как пузырьки.
Если по окончании пробега ни одного обмена элементов не было, значит упорядоченность достигнута, и сортировка закончена.

Например, у нас есть массив (4,3,1,2).
Делаем первый пробег:
4,3,1,2 - 3,4,1,2 - 3,1,4,2 - 3,1,2,4
Второй пробег:
3,1,2,4 - 1,3,2,4 - 1,2,3,4
Третий пробег:
1,2,3,4 - закончили.
Недостаток -- в большом количестве итераций.

Третий тип -- сортировка вставками, будет рассмотрен в следующем занятии.

3. Задание

3.1. Реализуйте функцию для одного шага сортировки выбором, 
которая получает на вход массив целых чисел (передаётся по ссылке) и номер элемента i (i >= 0), 
и меняет в этом массиве i-й элемент местами с минимальным элементом в оставшейся части массива, начиная с элемента i+1.

Заголовок функции (псевдокод):
SelectionSortStep( int array[], int i )

3.2. Реализуйте функцию для одного шага сортировки пузырьком, которая получает на вход массив целых чисел (передаётся по ссылке), 
и выполняет один пробег по массиву от начала к концу, меняя местами каждые два элемента i и i+1, если i-й элемент больше i+1-го. 
Функция возвращает true, если по окончании пробега не было ни одного обмена элементов.

bool BubbleSortStep( int array[] )

Решение: SortLevelForSolving_001

2. Сортировка вставками
Это третий вид простых базовых сортировок, выполняющихся за O(n^2).

Двигаясь по массиву с первого элемента, берём очередной i-й элемент 
и ставим его в предыдущую последовательность (от нуля до i-1) так, 
чтобы в этой последовательности сохранялась упорядоченность.

Например, у нас есть массив (4,3,1,2).
Начинаем с элемента 3 -- вставляем его в начало:
3,4,1,2
Следующий элемент 1 - вставляем его первым перед 3,4:
1,3,4,2
Последний элемент 2 -- вставляем его после 1:
1,2,3,4
Главный недостаток этого способа -- необходимость часто сдвигать большие последовательности в массиве, 
особенно если в конце хранятся маленькие значения.

Задание

Реализуйте предварительный алгоритм для сортировки вставками с дополнительным параметром -- шагом сортировки.

Например, если есть массив (7,6,5,4,3,2,1), и мы задаём шаг сортировки 3, то мы в цикле, начиная с i-го элемента, 
сортируем в массиве только те последующие элементы, которые отстоят друг от друга на этот шаг.

Исходный массив будет меняться так:

i=0
7,6,5,4,3,2,1
1,6,5,4,3,2,7
i=1
1,3,5,4,6,2,7
i=2
1,3,2,4,6,5,7
i=3
1,3,2,4,6,5,7
Ещё раз:
если i=0 и шаг=3, то соответственно,
из 7,6,5,4,3,2,1 выделили 7,4,1 через шаг 3
отсортировали, получили 1,4,7
и с учётом их оригинальных позиций в массиве и получилось 1,6,5,4,3,2,7 .

Если шаг равен 1, тогда алгоритм будет работать стандартным образом.

Шаг сортировки понадобится далее, при реализации эффективных алгоритмов сортировки.

Пока данный алгоритм не выполняет полную сортировку, он только готовит массив к следующему шагу.

О важности выбора правильного алгоритма, и почему их так много.
Возьмём конкретный случай, когда надо отсортировать два миллиона целых чисел.
Сортировка вставками будет тут работать за O(2*N^2), а сортировка слиянием, которую мы изучим позже, за O(50*N*log N).
Пусть у нас имеется два компьютера: А с производительностью 10 миллиардов инструкций в секунду, 
и Б с производительностью 10 миллионов инструкций в секунду. 
На компьютере А мы будем применять сортировку вставками, а на компьютере Б -- сортировку слиянием. 
Тогда на компьютере А сортировка продлится примерно 5,5 часов, 
а на компьютере Б (который в тысячу раз медленнее) -- примерно 20 минут.

Задание

Реализуйте функцию для одного шага сортировки вставкой (по возрастанию), 
которая получает на вход массив целых чисел (передаётся по ссылке), размер шага (>= 1) и номер элемента i (i >= 0), 
с которого выполняется один шаг сортировки.

Заголовок функции (псевдокод):

InsertionSortStep( int[] array, int step, int i )
Например, вызов InsertionSortStep( [1,6,5,4,3,2,7], 3, 1 ) изменит входной массив на [1,3,5,4,6,2,7].

Решение: SortLevelForSolving_002


3. Сортировка Шелла

Сортировка Шелла -- это скорее эвристический алгоритм, который в среднем показывает неплохую скорость порядка O(n * (log n)^2). 
При этом, что очень важно, даже если на вход поступает самый "плохой" вариант для сортировки, 
данный алгоритм справляется с ним примерно за то же время. 
Поэтому сортировку Шелла можно всегда использовать как палочку-выручалочку, и только если в конкретной задаче он работает плохо, 
переходить к более сложным эффективным алгоритмам.

Идея сортировки Шелла довольно проста и заключается в том, что если у нас элементы упорядочены наихудшим образом, 
перемещение правых элементов влево по одному шагу может потребовать слишком много ресурсов. 
Сортировка Шелла придерживается такой схемы: сперва мы сортируем элементы с шагом N (как мы делали в прошлом занятии), 
затем уменьшаем этот шаг, снова сортируем, и так далее до шага 1. 
При этом, за счёт того, что после каждого прохода данные у нас немного упорядочиваются, 
каждый следующий проход выполняется значительно быстрее -- фактически стремится к O(n).

Какую последовательность шагов брать? 
Существует, например, рекомендованная интервальная последовательность Кнута -- ..., 364, 121, 40, 13, 4, 1. 
Эта последовательность генерируется по формуле

N(i) = 3 * N(i-1) + 1
где N(0) - это самый первый шаг, единица.

Например, у нас есть массив из 15 элементов. 
Тогда мы начинаем с шага 13 и выполняем сортировку так (считаем первый элемент массива 0-м):

Проход 1.
Сортируем:
0-й и 13-й элементы
1-й и 14-й элементы

Проход 2.
Теперь переходим к шагу 4:
Сортируем:
0-й, 4-й, 8-й, 12-й элементы
1-й, 5-й, 9-й, 13-й элементы
2-й, 6-й, 10-й, 14-й элементы
3-й, 7-й, 11-й элементы

Проход 3.
Теперь последний шаг 1 -- просто сортируем
классическим способом все элементы подряд.

Задание.

Дополните предыдущее задание функцией, которая по параметру n >= 0 (размер массива) вычислит нужную интервальную последовательность целых чисел (список для Python, List для C#, ArrayList для Java).

Заголовок функции (псевдокод):

KnuthSequence( int array_size )
Например, вызов KnuthSequence(15) вернёт список [13, 4, 1].
