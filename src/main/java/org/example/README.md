1. Сортировка (базовое)
Алгоритмы сортировки -- это очень важный класс алгоритмов, который занимается упорядочиванием элементов в массиве (списке). 
Проблема в том, что самые простые алгоритмы, очевидные в реализации, одновременно и самые неэффективные, медленные. 
Их сложность начинается с O(n^2) и выше, а на практике типичны задачки, когда надо отсортировать наборы 
из миллионов или миллиардов значений.
К простым алгоритмам сортировки обычно относят три типа алгоритмов (рассматриваем упорядочивание по возрастанию).

1. Сортировка выбором

Двигаясь по массиву с начала, берём очередной i-й элемент и меняем его местами с минимальным элементом 
в оставшейся последовательности, начиная с элемента i+1, если этот минимальный элемент меньше текущего.

Например, у нас есть массив (4,3,1,2).
Меняем 0-й элемент 4 и 1:
1,3,4,2
Следующий, 1-й элемент 3 -- меняем с элементом 2:
1,2,4,3
Следующий, 2-й элемент 4 -- меняем с последним элементом 3:
1,2,3,4
Минус, что надо постоянно выполнять поиск минимального элемента.

2. Сортировка пузырьком

Организуем бесконечный цикл, внутри которого выполняем последовательный пробег по всем элементам массива, 
кроме последнего, проверяя, больше ли текущий элемент следующего. Если больше, меняем их местами. 
Таким образом все меньшие элементы постепенно "всплывают" вверх (к началу массива) как пузырьки.
Если по окончании пробега ни одного обмена элементов не было, значит упорядоченность достигнута, и сортировка закончена.

Например, у нас есть массив (4,3,1,2).
Делаем первый пробег:
4,3,1,2 - 3,4,1,2 - 3,1,4,2 - 3,1,2,4
Второй пробег:
3,1,2,4 - 1,3,2,4 - 1,2,3,4
Третий пробег:
1,2,3,4 - закончили.
Недостаток -- в большом количестве итераций.

Третий тип -- сортировка вставками, будет рассмотрен в следующем занятии.

3. Задание

3.1. Реализуйте функцию для одного шага сортировки выбором, 
которая получает на вход массив целых чисел (передаётся по ссылке) и номер элемента i (i >= 0), 
и меняет в этом массиве i-й элемент местами с минимальным элементом в оставшейся части массива, начиная с элемента i+1.

Заголовок функции (псевдокод):
SelectionSortStep( int array[], int i )

3.2. Реализуйте функцию для одного шага сортировки пузырьком, которая получает на вход массив целых чисел (передаётся по ссылке), 
и выполняет один пробег по массиву от начала к концу, меняя местами каждые два элемента i и i+1, если i-й элемент больше i+1-го. 
Функция возвращает true, если по окончании пробега не было ни одного обмена элементов.

bool BubbleSortStep( int array[] )

Решение: SortLevelForSolving_001

2. Сортировка вставками
Это третий вид простых базовых сортировок, выполняющихся за O(n^2).

Двигаясь по массиву с первого элемента, берём очередной i-й элемент 
и ставим его в предыдущую последовательность (от нуля до i-1) так, 
чтобы в этой последовательности сохранялась упорядоченность.

Например, у нас есть массив (4,3,1,2).
Начинаем с элемента 3 -- вставляем его в начало:
3,4,1,2
Следующий элемент 1 - вставляем его первым перед 3,4:
1,3,4,2
Последний элемент 2 -- вставляем его после 1:
1,2,3,4
Главный недостаток этого способа -- необходимость часто сдвигать большие последовательности в массиве, 
особенно если в конце хранятся маленькие значения.

Задание

Реализуйте предварительный алгоритм для сортировки вставками с дополнительным параметром -- шагом сортировки.

Например, если есть массив (7,6,5,4,3,2,1), и мы задаём шаг сортировки 3, то мы в цикле, начиная с i-го элемента, 
сортируем в массиве только те последующие элементы, которые отстоят друг от друга на этот шаг.

Исходный массив будет меняться так:

i=0
7,6,5,4,3,2,1
1,6,5,4,3,2,7
i=1
1,3,5,4,6,2,7
i=2
1,3,2,4,6,5,7
i=3
1,3,2,4,6,5,7
Ещё раз:
если i=0 и шаг=3, то соответственно,
из 7,6,5,4,3,2,1 выделили 7,4,1 через шаг 3
отсортировали, получили 1,4,7
и с учётом их оригинальных позиций в массиве и получилось 1,6,5,4,3,2,7 .

Если шаг равен 1, тогда алгоритм будет работать стандартным образом.

Шаг сортировки понадобится далее, при реализации эффективных алгоритмов сортировки.

Пока данный алгоритм не выполняет полную сортировку, он только готовит массив к следующему шагу.

О важности выбора правильного алгоритма, и почему их так много.
Возьмём конкретный случай, когда надо отсортировать два миллиона целых чисел.
Сортировка вставками будет тут работать за O(2*N^2), а сортировка слиянием, которую мы изучим позже, за O(50*N*log N).
Пусть у нас имеется два компьютера: А с производительностью 10 миллиардов инструкций в секунду, 
и Б с производительностью 10 миллионов инструкций в секунду. 
На компьютере А мы будем применять сортировку вставками, а на компьютере Б -- сортировку слиянием. 
Тогда на компьютере А сортировка продлится примерно 5,5 часов, 
а на компьютере Б (который в тысячу раз медленнее) -- примерно 20 минут.

Задание

Реализуйте функцию для одного шага сортировки вставкой (по возрастанию), 
которая получает на вход массив целых чисел (передаётся по ссылке), размер шага (>= 1) и номер элемента i (i >= 0), 
с которого выполняется один шаг сортировки.

Заголовок функции (псевдокод):

InsertionSortStep( int[] array, int step, int i )
Например, вызов InsertionSortStep( [1,6,5,4,3,2,7], 3, 1 ) изменит входной массив на [1,3,5,4,6,2,7].

Решение: SortLevelForSolving_002


3. Сортировка Шелла

Сортировка Шелла -- это скорее эвристический алгоритм, который в среднем показывает неплохую скорость порядка O(n * (log n)^2). 
При этом, что очень важно, даже если на вход поступает самый "плохой" вариант для сортировки, 
данный алгоритм справляется с ним примерно за то же время. 
Поэтому сортировку Шелла можно всегда использовать как палочку-выручалочку, и только если в конкретной задаче он работает плохо, 
переходить к более сложным эффективным алгоритмам.

Идея сортировки Шелла довольно проста и заключается в том, что если у нас элементы упорядочены наихудшим образом, 
перемещение правых элементов влево по одному шагу может потребовать слишком много ресурсов. 
Сортировка Шелла придерживается такой схемы: сперва мы сортируем элементы с шагом N (как мы делали в прошлом занятии), 
затем уменьшаем этот шаг, снова сортируем, и так далее до шага 1. 
При этом, за счёт того, что после каждого прохода данные у нас немного упорядочиваются, 
каждый следующий проход выполняется значительно быстрее -- фактически стремится к O(n).

Какую последовательность шагов брать? 
Существует, например, рекомендованная интервальная последовательность Кнута -- ..., 364, 121, 40, 13, 4, 1. 
Эта последовательность генерируется по формуле

N(i) = 3 * N(i-1) + 1
где N(0) - это самый первый шаг, единица.

Например, у нас есть массив из 15 элементов. 
Тогда мы начинаем с шага 13 и выполняем сортировку так (считаем первый элемент массива 0-м):

Проход 1.
Сортируем:
0-й и 13-й элементы
1-й и 14-й элементы

Проход 2.
Теперь переходим к шагу 4:
Сортируем:
0-й, 4-й, 8-й, 12-й элементы
1-й, 5-й, 9-й, 13-й элементы
2-й, 6-й, 10-й, 14-й элементы
3-й, 7-й, 11-й элементы

Проход 3.
Теперь последний шаг 1 -- просто сортируем
классическим способом все элементы подряд.

Задание.

Дополните предыдущее задание функцией, которая по параметру n >= 0 (размер массива) вычислит нужную интервальную последовательность 
целых чисел (список для Python, List для C#, ArrayList для Java).

Заголовок функции (псевдокод):

KnuthSequence( int array_size )
Например, вызов KnuthSequence(15) вернёт список [13, 4, 1].

Решение: SortLevelForSolving_003


4. Алгоритм разбиения массива
   Алгоритм разбиения массива на две группы -- это промежуточный шаг к классической быстрой сортировке, которая существенно обгоняет сортировку Шелла на больших наборах данных (от десятков тысяч элементов).

Смысл разбиения -- разделить массив (мутабельный список) на две группы, в левой из которых собраны его элементы, меньшие некоторого порогового значения, называемого опорным, а в правой части собраны элементы, большие этого опорного значения. Выбор опорного значения -- достаточно тонкий момент, который реализуется в зависимости от решаемой задачи, и сам алгоритм тоже зависит от способа такого выбора.

Мы рассмотрим вариант, когда в качестве опорного значения выбирается центральное значение в массиве. Подразумевается, что значение опорного элемента в массиве ровно одно, и в целом, в массиве нету одинаковых элементов (в противном случае используются более сложные схемы сортировки, когда массив разбивается на три группы, и одинаковые значения опорного элемента включаются в третью группу).

Алгоритм разбиения массива M такой:

0. В переменную N заносим опорное значение, которое хранится в массиве по индексу, равному (длина массива / 2), 
    где / -- целочисленное деление (7/2=3). Запоминаем также индекс опорного элемента.

1. В переменную i1 заносим 0 (индекс первого элемента), а в переменную i2 - длину массива M минус один (индекс последнего элемента).

2. Пока значение M[ i1 ] меньше N , увеличиваем i1 на 1.

3. Пока значение M[ i2 ] больше N , уменьшаем i2 на 1.

4. Если i1 = i2 - 1 и M[i1] > M[i2], то меняем M[i1] и M[i2] местами, и возвращаемся к п. 0.

5. Если i1 = i2 или (i1 = i2 - 1 и M[i1] < M[i2]), то возвращаем индекс финальной позиции опорного элемента, и прекращаем работу.

6. К данному пункту M[i1] хранит элемент, больший или равный опорному, а M[i2] хранит элемент, меньший или равный опорному. 
   Меняем их местами (если один из них -- опорный элемент, надо обновить его новый индекс), и переходим к п.2.

Задание.

Напишите функцию ArrayChunk, которая получает в качестве параметра массив (по ссылке), выполняет разбиение его на две группы, 
и возвращает индекс опорного элемента.

Заголовок функции (псевдокод):

int ArrayChunk( int[] M )
Например, вызов ArrayChunk( [7,5,6,4,3,1,2] ) вернёт 3, а массив примет значение [2,1,3,4,6,5,7].

Решение: SortLevelForSolving_004


5. Быстрая сортировка Хоара
   Это самый популярный на сегодня алгоритм сортировки, который показывает сложность O(N * log N). 
Он основан на алгоритме разбиения, когда мы делим сортируемый массив/список на две группы, 
к которым несколько парадоксально применяется рекурсия.

Алгоритм быстрой сортировки -- это рекурсивное применение его самого к каждой из групп, выделяемых с помощью алгоритма разбиения.

Остаётся вроде бы открытым вопрос: а в какой момент выполняется сама сортировка? 
Но вспомним, что алгоритм разбиения уже делит массив на группы, в одной из которых собраны все меньшие, 
а в другой -- все большие элементы. 
Таким образом сама сортировка происходит в некотором смысле автоматически, без явных упорядочиваний.

Рекурсивная функция QuickSort() получает на вход массив (по ссылке) и два параметра: 
left и right, которые по сути имеют смысл левого и правого индексов в алгоритме разбиения. 
Сперва мы проверяем, если left и right равны, значит сортировка закончена (массив из одного элемента упорядочен по определению).

В противном случае мы сначала вызываем из прошлого занятия алгоритм разбиения для диапазона значений left .. right, 
который вносит соответствующие изменения в этот диапазон (разбивает его на два поддиапазона), и возвращает индекс N опорного элемента.
Теперь естественным образом слева от опорного элемента будут находиться заведомо меньшие элементы, 
а справа заведомо большие. 
Мы можем считать, что наш опорный элемент уже находится в "отсортированном" месте, и из дальнейшего разбиения его можно исключить.

Поэтому двумя следующими шагами после разбиения мы просто вызываем

QuickSort( array, left, N-1 )
и
QuickSort( array, N+1, right )
где N -- это индекс опорного элемента.
Задание.

Напишите функцию QuickSort(), которая получает в качестве параметра массив (по ссылке) и два индекса, выполняет разбиение его на два диапазона (и опорный элемент), и вызывает саму себя для каждого из диапазонов.

Заголовок функции (псевдокод):

void QuickSort( int[] array, int left, int right )